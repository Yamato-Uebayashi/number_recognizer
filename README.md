# 概要
  これは白黒の手書き数字を判定する単純なOCRです。僕が高専3年生の夏休みにプログラミングという科目の自由課題として作成しました。
  この課題ではオブジェクト指向の機能を使わなければならないとの制約を設けられた為、重みやバイアスなどのパラメータを行列で扱うのではなくニューロン1つ1つにメンバとして持たせる形となっています。
  AIの仕組みを理解しながら動かしてみるという目的で作ったものなので計算効率は度外視しており、故に正答率90%超えを狙った設定にすると訓練に20分ほどかかる事が多いです(後述の環境で実行した場合)。

# 仕様
  ## モデルの構造
  複数のニューロンを含む層がいくつか並んでいるような構造をしています。層をいくつ作るか、各層がそれぞれいくつのニューロンを持つのかという情報はユーザから標準入力で受け取ります(これに限らず、ユーザとのやり取りは画像ファイルの取り込みを除いて全て標準入出力です)。
  その後、バッチサイズとエポック数、学習率も受け取って訓練を進めていきます。訓練は受け取った画像を元に順伝播と誤差逆伝播を繰り返す単純なものです。使う活性化関数は、出力層ではSoftmax、それ以外ではLeakyReLU(係数は-0.04)にしています。
  
  ## 流れ
  このプログラムを実行すると、次に示す4つの選択肢が表示されます。
  1. 新しいモデルを作る
  1. モデルを読み込んで自動試験
  1. モデルを読み込んで手動試験
  1. 終了
     
  1を選んだ場合、前述の手順で必要なパラメータを受け取り、それに従ってモデルを訓練します。訓練中はデバッグ用に損失やイテレーション、エポック数や学習率、出力層の各アクティベーションの値などを表示します。
  学習が終わるとユーザから文字列を受け取ってそれをモデル名とし、save_datasディレクトリにモデルを保存します。
    
  2あるいは3を選んだ場合、文字列をユーザから受け取り、その名前のモデルをsave_datasディレクトリからロードします。\
  2ではEMNISTデータセットの試験用データ40000枚の数字の判定をし、損失の平均と正答率を出力します。
  3ではtest_imageディレクトリ内の画像データを判定し、その後モデルが0~9それぞれについてどれだけの確率であると判断したかが出力されます。
  
  4を選ぶとプログラムを終了します。
  
  ## 外部のソフトウェア・データセット
  読み込む画像を手書き入力にて作成するにはProcessing言語で開発した別プログラム[character_input](https://github.com/Yamato-Uebayashi/character_input)を使用する必要があります。
  その画面は 28 * 28 = 784 ピクセルの白黒キャンバスを含んでおり、ユーザはをこれを使って数字を手書きして保存する事ができます。\
  そうして作った画像データ(.bin形式)を本プロジェクトのtest_imageディレクトリに移動させると、自分の手書き文字を判定させる事ができます。\
  モデルの訓練および試験に使うデータは[EMNISTデータセット](https://web.archive.org/web/20200723165422/https://www.nist.gov/itl/products-and-services/emnist-dataset)にて無料配布されているものを利用しました。

# 開発環境
Rustコンパイラ、エディタ、ターミナル、シェルのバージョンは記録していなかった為不明ですが、動作確認ができた最新のバージョンを記載しています。
| 項目 | 仕様 |
| :--- | :--- |
| PCの型番 | dynabook GZ/HUL W6GZHU7XBL |
| OS | Ubuntu24.04LTS<br>Ubuntu24.10 |
| CPU | 11th Gen Intel i7-1195G7 (8) @ 5.000GHz |
| メモリ容量 | 15142MB |
| ターミナル | gnome-terminal 3.54.0 |
| シェル | bash 5.2.32 |
| Rustコンパイラのバージョン | 1.86.0 |
| エディタ | Visual Studio Code 1.99.3<br>Zed 0.183.11 |

# 今後について
できればもっと高速化したいですが、僕はグラフィックボード非搭載のノートPCしか持っておらず、CPUの内蔵グラフィックは Intel TigerLake-LP GT2 [Iris Xe Graphics] というよく分からないものなのでGPUによる並列化は恐らくしません。試すとすればrayonなどでCPUによる並列化をするなどです。\
また、Rust言語の技術不足で残してしまった無駄な処理も多いので、それもなんとかしたいです。例えばネットワークのコードは訓練用の複雑なものと判定用の軽量なもので2種類に分けているのですが、共通する処理をトレイトとして切り出す方法を当時は知らなかったので大量の重複するコードを書いてしまっています。こちらは比較的簡単なので時間があれば修正したいと思います。\
ただ、最近は宿題やら進路の調べものやらで時間がないのでこのまま放置するかも知れません。
